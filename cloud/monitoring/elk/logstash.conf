# ===============================================
# LOGSTASH CONFIGURATION
# ===============================================
# Log processing pipeline for trading bot platform

input {
  # Kubernetes logs via Filebeat
  beats {
    port => 5044
    host => "0.0.0.0"
  }

  # Direct TCP input for application logs
  tcp {
    port => 5000
    codec => json_lines
  }

  # HTTP endpoint for webhook logs
  http {
    port => 8080
    codec => json
  }

  # Trading bot specific logs
  file {
    path => "/logs/trading/*.log"
    start_position => "beginning"
    codec => "json"
    tags => ["trading", "application"]
  }

  # API access logs
  file {
    path => "/logs/api/*.log"
    start_position => "beginning"
    codec => "json"
    tags => ["api", "access"]
  }

  # System metrics logs
  file {
    path => "/logs/system/*.log"
    start_position => "beginning"
    tags => ["system", "metrics"]
  }
}

filter {
  # ===============================================
  # KUBERNETES LOG PROCESSING
  # ===============================================
  if [kubernetes] {
    # Extract Kubernetes metadata
    mutate {
      add_field => { "k8s_namespace" => "%{[kubernetes][namespace]}" }
      add_field => { "k8s_pod" => "%{[kubernetes][pod][name]}" }
      add_field => { "k8s_container" => "%{[kubernetes][container][name]}" }
    }

    # Parse container logs
    if [k8s_container] =~ /orchestrator/ {
      grok {
        match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] %{DATA:component}: %{GREEDYDATA:log_message}" }
      }
      mutate { add_tag => ["trading", "orchestrator"] }
    }

    if [k8s_container] =~ /api/ {
      # Parse API logs (assuming JSON format)
      if [message] =~ /^\{/ {
        json {
          source => "message"
        }
        mutate { add_tag => ["api", "json"] }
      } else {
        # Parse non-JSON API logs
        grok {
          match => { "message" => "%{COMBINEDAPACHELOG}" }
        }
        mutate { add_tag => ["api", "access"] }
      }
    }

    if [k8s_container] =~ /dashboard/ {
      grok {
        match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:log_message}" }
      }
      mutate { add_tag => ["dashboard"] }
    }
  }

  # ===============================================
  # TRADING SPECIFIC LOG PROCESSING
  # ===============================================
  if "trading" in [tags] {
    # Parse trading events
    if [log_message] =~ /TRADE/ {
      grok {
        match => {
          "log_message" => "TRADE %{WORD:action} %{WORD:symbol} %{NUMBER:quantity:float} @ %{NUMBER:price:float} \(PnL: %{NUMBER:pnl:float}\)"
        }
      }
      mutate {
        add_tag => ["trade_execution"]
        add_field => { "event_type" => "trade" }
      }
    }

    # Parse risk management events
    if [log_message] =~ /RISK/ {
      grok {
        match => {
          "log_message" => "RISK %{WORD:risk_action} %{GREEDYDATA:risk_reason}"
        }
      }
      mutate {
        add_tag => ["risk_management"]
        add_field => { "event_type" => "risk" }
      }
    }

    # Parse market data events
    if [log_message] =~ /MARKET/ {
      grok {
        match => {
          "log_message" => "MARKET %{WORD:symbol} price:%{NUMBER:market_price:float} volume:%{NUMBER:volume:float}"
        }
      }
      mutate {
        add_tag => ["market_data"]
        add_field => { "event_type" => "market" }
      }
    }

    # Parse strategy events
    if [log_message] =~ /STRATEGY/ {
      grok {
        match => {
          "log_message" => "STRATEGY %{WORD:strategy_name} %{WORD:signal} %{WORD:symbol} confidence:%{NUMBER:confidence:float}"
        }
      }
      mutate {
        add_tag => ["strategy_signal"]
        add_field => { "event_type" => "strategy" }
      }
    }
  }

  # ===============================================
  # API LOG PROCESSING
  # ===============================================
  if "api" in [tags] {
    # Parse API response times
    if [response_time] {
      if [response_time] > 1000 {
        mutate { add_tag => ["slow_api"] }
      }
    }

    # Identify trading endpoints
    if [request] =~ /\/api\/trade/ {
      mutate { add_tag => ["trading_api"] }
    }

    if [request] =~ /\/api\/portfolio/ {
      mutate { add_tag => ["portfolio_api"] }
    }

    if [request] =~ /\/api\/market/ {
      mutate { add_tag => ["market_api"] }
    }

    # Parse user agent for bot detection
    if [agent] =~ /bot|crawler|spider/i {
      mutate { add_tag => ["bot_traffic"] }
    }
  }

  # ===============================================
  # ERROR PROCESSING
  # ===============================================
  if [level] =~ /ERROR|CRITICAL|FATAL/i {
    mutate { add_tag => ["error"] }

    # Extract error patterns
    if [log_message] =~ /Exception|Error|Failed/ {
      grok {
        match => {
          "log_message" => "%{WORD:error_type}.*: %{GREEDYDATA:error_message}"
        }
      }
    }

    # Trading specific errors
    if [log_message] =~ /OrderRejected|InsufficientFunds|MarketClosed/ {
      mutate { add_tag => ["trading_error"] }
    }
  }

  # ===============================================
  # SECURITY EVENTS
  # ===============================================
  if [log_message] =~ /authentication|login|logout|unauthorized/i {
    mutate { add_tag => ["security"] }
  }

  if [status] >= 400 {
    mutate { add_tag => ["http_error"] }

    if [status] >= 500 {
      mutate { add_tag => ["server_error"] }
    }
  }

  # ===============================================
  # PERFORMANCE METRICS
  # ===============================================
  if [response_time] {
    if [response_time] > 5000 {
      mutate { add_tag => ["very_slow"] }
    } else if [response_time] > 1000 {
      mutate { add_tag => ["slow"] }
    }
  }

  # ===============================================
  # TIMESTAMP PROCESSING
  # ===============================================
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }

  # Remove raw message if parsed successfully
  if [log_message] {
    mutate { remove_field => ["message"] }
  }

  # Add environment information
  mutate {
    add_field => { "environment" => "production" }
    add_field => { "platform" => "trading-bot" }
  }

  # Geo IP lookup for external requests
  if [client_ip] and [client_ip] !~ /^(10\.|172\.|192\.168\.)/ {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # ===============================================
  # DATA ENRICHMENT
  # ===============================================
  # Add trading session information
  if "trading" in [tags] {
    ruby {
      code => "
        require 'time'
        current_time = Time.parse(event.get('@timestamp').to_s)

        # Determine trading session
        if current_time.hour >= 9 && current_time.hour < 16
          event.set('trading_session', 'market_hours')
        else
          event.set('trading_session', 'after_hours')
        end

        # Add market day
        if current_time.wday >= 1 && current_time.wday <= 5
          event.set('market_day', 'weekday')
        else
          event.set('market_day', 'weekend')
        end
      "
    }
  }

  # ===============================================
  # FIELD CLEANUP
  # ===============================================
  mutate {
    remove_field => ["host", "agent", "ecs", "input", "prospector"]
  }

  # Convert numeric strings to numbers
  mutate {
    convert => {
      "quantity" => "float"
      "price" => "float"
      "pnl" => "float"
      "confidence" => "float"
      "response_time" => "integer"
      "status" => "integer"
    }
  }
}

output {
  # ===============================================
  # ELASTICSEARCH OUTPUT
  # ===============================================
  elasticsearch {
    hosts => ["elasticsearch:9200"]

    # Index strategy based on log type and date
    index => "trading-platform-%{+YYYY.MM.dd}"

    # Custom index for different log types
    if "trading" in [tags] {
      index => "trading-logs-%{+YYYY.MM.dd}"
    } else if "api" in [tags] {
      index => "api-logs-%{+YYYY.MM.dd}"
    } else if "system" in [tags] {
      index => "system-logs-%{+YYYY.MM.dd}"
    } else if "error" in [tags] {
      index => "error-logs-%{+YYYY.MM.dd}"
    }

    # Template for index settings
    template_name => "trading-platform"
    template => "/usr/share/logstash/templates/trading-platform.json"
    template_overwrite => true

    # Performance settings
    flush_size => 1000
    idle_flush_time => 1
  }

  # ===============================================
  # ALERTING OUTPUTS
  # ===============================================
  # Send critical errors to alerting system
  if "error" in [tags] and [level] =~ /CRITICAL|FATAL/i {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      content_type => "application/json"
      format => "json"
      mapping => {
        "alerts" => [
          {
            "labels" => {
              "alertname" => "CriticalLogError"
              "severity" => "critical"
              "service" => "%{k8s_container}"
              "namespace" => "%{k8s_namespace}"
            }
            "annotations" => {
              "summary" => "Critical error in %{k8s_container}"
              "description" => "%{log_message}"
            }
          }
        ]
      }
    }
  }

  # Send trading errors to Slack
  if "trading_error" in [tags] {
    http {
      url => "${SLACK_WEBHOOK_URL}"
      http_method => "post"
      content_type => "application/json"
      format => "json"
      mapping => {
        "channel" => "#trading-alerts"
        "username" => "TradingBot"
        "text" => "ğŸš¨ Trading Error: %{error_message}"
        "attachments" => [
          {
            "color" => "danger"
            "fields" => [
              {
                "title" => "Service"
                "value" => "%{k8s_container}"
                "short" => true
              }
              {
                "title" => "Time"
                "value" => "%{@timestamp}"
                "short" => true
              }
            ]
          }
        ]
      }
    }
  }

  # ===============================================
  # DEBUGGING OUTPUT
  # ===============================================
  # Uncomment for debugging
  # stdout { codec => rubydebug }
}