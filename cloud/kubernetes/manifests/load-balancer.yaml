# ===============================================
# LOAD BALANCER SERVICES CONFIGURATION
# ===============================================
# Enterprise load balancing with health checks and failover

# External Load Balancer for Public Access
apiVersion: v1
kind: Service
metadata:
  name: external-load-balancer
  namespace: trading-platform
  labels:
    app: external-load-balancer
    component: infrastructure
    tier: frontend
  annotations:
    # AWS Load Balancer Controller annotations
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
    service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "3600"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: "10"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout: "6"
    service.beta.kubernetes.io/aws-load-balancer-healthy-threshold: "2"
    service.beta.kubernetes.io/aws-load-balancer-unhealthy-threshold: "2"
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:region:account:certificate/certificate-id"
    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"
    service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: "ELBSecurityPolicy-TLS-1-2-2017-01"

    # GCP Load Balancer annotations
    cloud.google.com/load-balancer-type: "External"
    cloud.google.com/neg: '{"ingress": true}'
    cloud.google.com/backend-config: '{"default": "trading-backend-config"}'

    # Azure Load Balancer annotations
    service.beta.kubernetes.io/azure-load-balancer-internal: "false"
    service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "public-subnet"
    service.beta.kubernetes.io/azure-dns-label-name: "trading-platform"

spec:
  type: LoadBalancer
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 3600
  ports:
  - name: http
    port: 80
    targetPort: 80
    protocol: TCP
  - name: https
    port: 443
    targetPort: 443
    protocol: TCP
  selector:
    app: nginx-ingress-controller

---
# Internal Load Balancer for Service-to-Service Communication
apiVersion: v1
kind: Service
metadata:
  name: internal-load-balancer
  namespace: trading-platform
  labels:
    app: internal-load-balancer
    component: infrastructure
    tier: backend
  annotations:
    # AWS Internal Load Balancer
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internal"
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"

    # GCP Internal Load Balancer
    cloud.google.com/load-balancer-type: "Internal"
    networking.gke.io/load-balancer-type: "Internal"

    # Azure Internal Load Balancer
    service.beta.kubernetes.io/azure-load-balancer-internal: "true"
    service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "private-subnet"

spec:
  type: LoadBalancer
  ports:
  - name: orchestrator
    port: 8001
    targetPort: 8001
    protocol: TCP
  - name: api
    port: 8000
    targetPort: 8000
    protocol: TCP
  - name: dashboard
    port: 5000
    targetPort: 5000
    protocol: TCP
  selector:
    tier: backend

---
# ===============================================
# BACKEND CONFIGURATION FOR GCP
# ===============================================
apiVersion: cloud.google.com/v1
kind: BackendConfig
metadata:
  name: trading-backend-config
  namespace: trading-platform
spec:
  healthCheck:
    checkIntervalSec: 10
    timeoutSec: 5
    healthyThreshold: 2
    unhealthyThreshold: 3
    type: HTTP
    requestPath: /health
    port: 5000

  connectionDraining:
    drainingTimeoutSec: 300

  timeoutSec: 60

  logging:
    enable: true
    sampleRate: 1.0

  cdn:
    enabled: false
    cachePolicy:
      includeHost: true
      includeProtocol: true
      includeQueryString: false

  customRequestHeaders:
    headers:
    - "X-Trading-Platform:Kubernetes"
    - "X-Environment:Production"

---
# ===============================================
# MANAGED CERTIFICATE FOR GCP
# ===============================================
apiVersion: networking.gke.io/v1
kind: ManagedCertificate
metadata:
  name: trading-platform-ssl-cert
  namespace: trading-platform
spec:
  domains:
  - trading.example.com
  - dashboard.trading.example.com
  - api.trading.example.com

---
# ===============================================
# FRONTEND CONFIG FOR GCP
# ===============================================
apiVersion: networking.gke.io/v1beta1
kind: FrontendConfig
metadata:
  name: trading-frontend-config
  namespace: trading-platform
spec:
  sslPolicy: "trading-ssl-policy"
  redirectToHttps:
    enabled: true
    responseCodeName: MOVED_PERMANENTLY_DEFAULT

---
# ===============================================
# HIGH AVAILABILITY CONFIGURATION
# ===============================================
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: nginx-ingress-controller-pdb
  namespace: trading-platform
  labels:
    app: nginx-ingress-controller
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: nginx-ingress-controller

---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: dashboard-pdb
  namespace: trading-platform
  labels:
    app: dashboard
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: dashboard

---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: api-pdb
  namespace: trading-platform
  labels:
    app: api
spec:
  minAvailable: 3
  selector:
    matchLabels:
      app: api

---
# ===============================================
# NGINX INGRESS CONTROLLER DEPLOYMENT
# ===============================================
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: nginx-ingress-controller
  namespace: trading-platform
  labels:
    app: nginx-ingress-controller
    component: infrastructure
spec:
  selector:
    matchLabels:
      app: nginx-ingress-controller
  template:
    metadata:
      labels:
        app: nginx-ingress-controller
        component: infrastructure
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "10254"
    spec:
      serviceAccountName: nginx-ingress-serviceaccount
      hostNetwork: true
      dnsPolicy: ClusterFirstWithHostNet
      containers:
      - name: nginx-ingress-controller
        image: k8s.gcr.io/ingress-nginx/controller:v1.8.2
        args:
        - /nginx-ingress-controller
        - --configmap=$(POD_NAMESPACE)/nginx-configuration
        - --tcp-services-configmap=$(POD_NAMESPACE)/tcp-services
        - --udp-services-configmap=$(POD_NAMESPACE)/udp-services
        - --publish-service=$(POD_NAMESPACE)/ingress-nginx
        - --annotations-prefix=nginx.ingress.kubernetes.io
        - --metrics-bind-address=0.0.0.0:10254
        - --enable-ssl-passthrough
        - --enable-ssl-chain-completion
        - --default-ssl-certificate=$(POD_NAMESPACE)/default-server-secret
        securityContext:
          allowPrivilegeEscalation: true
          capabilities:
            drop:
            - ALL
            add:
            - NET_BIND_SERVICE
          runAsUser: 101
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        ports:
        - name: http
          containerPort: 80
          hostPort: 80
        - name: https
          containerPort: 443
          hostPort: 443
        - name: metrics
          containerPort: 10254
        livenessProbe:
          httpGet:
            path: /healthz
            port: 10254
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /healthz
            port: 10254
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 3
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 1000m
            memory: 512Mi
      nodeSelector:
        kubernetes.io/os: linux
      tolerations:
      - effect: NoSchedule
        key: node-role.kubernetes.io/master
        operator: Equal
      - effect: NoSchedule
        key: node-role.kubernetes.io/control-plane
        operator: Equal

---
# ===============================================
# SERVICE ACCOUNT AND RBAC
# ===============================================
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nginx-ingress-serviceaccount
  namespace: trading-platform
  labels:
    app: nginx-ingress-controller

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: nginx-ingress-clusterrole
  labels:
    app: nginx-ingress-controller
rules:
- apiGroups: [""]
  resources: ["configmaps", "endpoints", "nodes", "pods", "secrets"]
  verbs: ["list", "watch"]
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create", "patch"]
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses/status"]
  verbs: ["update"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nginx-ingress-clusterrole-nisa-binding
  labels:
    app: nginx-ingress-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: nginx-ingress-clusterrole
subjects:
- kind: ServiceAccount
  name: nginx-ingress-serviceaccount
  namespace: trading-platform

---
# ===============================================
# CERTIFICATE ISSUER FOR AUTOMATIC SSL
# ===============================================
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@trading-platform.com
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
    - http01:
        ingress:
          class: nginx